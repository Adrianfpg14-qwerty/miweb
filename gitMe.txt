Git (02/04/2022)
Usos
-Historial
-Almacenar codigo
-Trabajar en equipo
-Cuando se introdujo un error


UN REPOSITORIO es un lugar para almacenar el codigo de forma ordenada y ordenada.
Hay herramientas graficas para ver los cambios y demas pero tienen sus limitaciones, la versión de terminal es la mas utilizada y la mas completa.


DESCARGA
git-scm.com (Link descarga)
Utiliza Git Bash (viene dentro de la instalación del setup para windows) como consola de comandos.

En GitBash (comandos de configuracion inicial)
git --version						    	            -> Version de windows
git config --global user.name "Adrian Polo"			    -> Para configurar git con nuestro nombre 
git congif --glogal user.email adrianfpg14@gmail.com    -> "" correo
git config --global core.editor "code --wait"			-> Para establecer Vs Code como editor de texto por defecto (wait para que la terminal espere a que cerremos el editor de texto)
git config --global -e 				            		-> Para ver nuestro archivo de config global (Todo esto que hemos hecho antes) [Solo me funciona dentro de vs code ctrl+ñ para abrir terminal]
git config --global core.autocrlf true				    -> True para windows | input para Mac (Esto es para compatibilidad de caracteres, saltos de linea y codigo en general para un proyecto en el que se encuentren trabajando personas con sistemas operativos diferentes.

PD: --global es para que sea una configuracion a nivel global no solo para un proyecto en especifico


COMANDOS PARA MOVERSE
ls			                -> Lista archivos y carpetas de un directorio (carpeta)
ls -a			            -> Para listar archivos ocultos
pwd			                -> Para saber donde me encuentro
cd NAMECARPETA	   	        -> Entrar a directorio
cd .. 		    	        -> Salir de directorio
rm NAMEFILE                 -> Elimina archivo
mkdir NAMECARPETA	        -> Crear directorio
rmdir                       -> Elimina directorio/carpeta



mv OLDNAMEFILE NEWNAMEFILE  -> Renombrar archivos y directorios/carpetas



MISCELANEOS
git config -h (Para realizar mas configuraciones en git si te apetece)
clear (ctrl + L)	-> Limpiar pantalla
code .              -> Dentro del proyecto, abre VS Code
explorer .          -> Para abrir el explorador de archivos de windows en ese directorio
cat NAMEFILE        -> Ver un archivo


COMANDOS PROYECTO
git init		    -> Debes estar ya dentro del directorio (Creará una carpeta/directorio .git dentro, que estará oculto para listarlo debes usar "ls -a") 

git status          -> Para ver el estado actual de nuestro repositorio.
    En que rama nos encontramos
    No commits yet (No hay commits aún)
    Untracked files (Archivos que no está siendo seguidos por git, para hacer que los sigan se debe usar git add.)

    La forma resumida es:
        git status -s (s de short)

    M   para modificaciones
    D   para eliminados
    ??  UNTRACKED archivos/directorios

git add             -> Por defecto git no sigue todos los archvios, para que lo haga debemos seleccionarlos, para esto es git add. Esto los agrega a la etapa de STAGE.
    git add NAMEFILE.txt
    git add NAMEFILE.txt NAMEFILE2.txt NAMEFILE3.txt
    git add * .txt  (Todos los que sean .txt)
    git add .       (Absolutamente todos los archivos en Untracked files (en rojo)) (NO USAR NUNCA, SE CONSIDERA MALA PRACTICA, a menos de que estes 100% seguro que todo es codigo util)

    Una vez agregados, git los seguira y al presionar nuevamente git status aparecerán en verde en etapa de STAGE.
    Si realizas un cambio, te aparecerá en rojo el archivo y dirá que ha sido modificado, para agregar el archivo con los cambios osea reemplazar, dale de nuevo con git add y el nombre del archivo nuevamente. Es como volverlo a subir, se reemplazará.
    En realidad no se reemplazará en sí el archivo, solo se reemplazarán las modificaciones/cambios que hallamos realizado.

git commit          -> commit=Comprometer. Subirá todos los que archivos que estén en la etapa de STAGE y al hacer git status ya no habrá ningun archivo.
    git commit -m "Mensaje con sentido"
    git commit (Abrirá VS Code para colocar el mensaje allá directamente, una vez hecho eso, cierra el archivo en VScode y vuelve al GitBash)

    Si modificas un archivo ya COMPROMETIDO (commitead, cosa que no existe en español) aparecerá modificado y tienes que nuevamente darle git add para agregarlos a la etapa de STAGE  y luego git commit.
    
    Si eliminas un archivo con rm NAMEFILE al darle git status te aparecerá en estado eliminado. Debes agregar a la etapa de STAGE con git add el archivo eliminado y luego dale en git commit para que se elimine con exito.
    En definitiva debes borrarlo primero y luego agregarlo a STAGE. Git hace estos 2 pasos con un solo comando. git rm NAMEFILE.

git rm              -> Borra y agrega al STAGE un archivo.
    git rm NAMEFILE
    git rm NAMEFILE NAMEFILE
    Literalmente git add/rm son para agregar al STAGE pero rm borra.

git restore         -> Trabaja en el STAGE.
    git restore --staged NAMEFILE
    - Archivo nuevo 
        Si ya lo habiamos subido al STAGE, lo bajará del STAGE a Untracked
    - Modifiqué un archivo
        Si ya habiamos subido sus cambios lo podemos poner en modo modificado nuevamente y seguir trabajando y luego si git add para agregar los cambios correctos. 
        No importa mucho ya que si igual ya está subido con sus cambios en STAGE, seguimos modificando y subimos los nuevos cambios y ya está, simple, sin andar restaurando nada, el STAGE sigue ahí en espera.

    git restore NAMEFILE
    Para restaurar los cambios modificados
    - Modifiqué un archivo
        Si ya lo habiamos agregado al STAGE con git add en un inicio, con git status veremos que hubo una modificación pero con git restore NAMEFILE el archivo que se halle en el STAGE reemplazará a la versión local.
    - Eliminé un archivo
        Si eliminé un archivo en directorio manualmente o con rm (no git rm porque lo agregará al STATUS) y se halla en el STATUS en modo deleted, podemos recuperarlo y aparecerá en el local nuevamennte.
        Si eliminé y agregué el cambio de eliminado al STATUS (con o sin git rm) ya no podemos darle git restore NAMEFILE amenos de que lo restauremos a su estado anterior con git restore --staged NAMEFILE para que quede en su anterior modo de color rojo deleted y ahí si recuperarlo con git restore NAMEFILE.

    En definitiva si modificamos un archivo y lo agregamos al STAGE y queremos que esos cambios no se suban y restaurar los cambios al local:
        git restore --staged NAMEFILE   (Ponerlo en rojo)
        git restore NAMEFILE            (Restaurarlo al local, osease recuperarlo)

mv OLDNAMEFILE NEWNAMEFILE  -> Renombrar archivos y directorios/carpetas
    Si lo haces te toca agregar al STAGE ambos cambios OLDNAMEFILE NEWNAMEFILE, 
    Con este comando cambias nombre y agregas al STAGE de una vez. 
        git mv OLDNAMEFILE NEWNAMEFILE


Archivo .gitignore
    Crea un archivo llamado .gitignore 
    Dentro especificas archivos o rutas para que ignorar y no vayan al repositorio 
    Archivo tal cual, directorio con / al final, separados por saltos de linea, ejm:
        .env
        mis_imagenes/
        node_modules/
    y agregalo al STATUS con git add .gitignore y comprometelo con git commit.

    FALSO. Cuando vamos a comprometer, todos los archivos deben estar en el STAGE por lo que si hay un archivo UNTRACKED o no seguido no se podrá comprometer (Archivos personales, archivos con configuraciones o de practica que no queremos subir al repositorio).
        Falso porque podemos comprometer teniendo archivos en UNTRACKED.
    VERDADERO. gitignore está para decirle a git que archivos o directorios (Archivos personales, archivos con configuraciones o de practica que no queremos subir al repositorio) no debe subir al repo y para que no nos aparezca que no están seguidos en UNTRACKED a cada rato.

git diff        -> Para ver los cambios realizados en una forma mas visual dentro de la terminal (SOLO ARCHIVOS CON MODIFICICACIONES NO SUBIDAS A STATUS)
    Si acabas de modificar algo escribe git diff y veras que se borró y que se agregó.
    Nota: Si te apareceriera lo mismo como si hubieras borrado y agregado lo mismo cuando en realidad no lo hiciste sucede porque diste un enter al final (salto de linea) y git lo considera una alteración ya que está al final de esa linea.
    Nota 2: Si git diff no te deja salir, presiona la q y listo.
    git diff --staged       -> Ver las modificaciones de los archivos en etapa de STAGE (ARCHIVOS CON MODIFICICACIONES YA SUBIDOS A STATUS)
    

VER HISTORIAL
    git log             -> Revisar todo el historial. Se verán name, correo, mensaje de commit.
    git log --oneline   -> Mejor apartado visual, saldrán los cambios separados por hashes y al frente su mensaje de commit.
    Nota: q para salir.

    El proyecto es lineal, y se mostrará en la parte de abajo el inicio del proyecto y arriba lo actual.
    La cabeza es el ultimo commit realizado en una rama.
    (main)  Es la cabeza del main.
        (NAMERAMA)  Cabeza de una rama.

    (HEAD -> main)  HEAD indica en que nos encontramos en esa rama.


BRANCH Y MERGE
    Branch es realizar una bifurcación de la rama principal creando una rama aparte y trabajar en ella para mas tarde solicitar pegarnos nuevamenTe a la rama principal (main)(a este proceso se la conoce como merge).
    Creamos la rama (independiente de la principal), le agregamos commits y luego volvemos a la main.
    
    SABER EN QUE RAMA NOS ENCONTRAMOS
    La rama main es la principal.
    git Branch          -> Para saber en que rama nos encontramos. La que esté en verde con el asterisco * a la izq es la rama en la que nos encontramos.
    
    CREAR UNA RAMA
    git checkout -b NAMERAMA
        git checkout -b features/name-de-la-funcionalidad   -> Algunas empresas lo hacen así
        git checkout -b SS-46-7WDA                          -> Otra así, colocando un numero de TICKET (esos numeros ellos se los inventan).

    ELIMINAR UNA RAMA


    CAMBIARNOS DE RAMA
    git checkout NAMERAMA
        Si te cambias de rama y hay un archivo de igual nombre en ambos el archivo en el local cambia. Chacalida BD.
        Cada rama tiene sus propios archivos commiteados por lo que si te cambias de rama estos archivos apareceran en el local (y volveran a desaparecerse al cambiar).
        
        Aquellos archivos nuevos, saldrán como UNTRACKED en cualquier rama que estes, debes agregarlo.
        El STAGE en sí no está en ninguna rama, es solo como una mesa en la que se ponen cosas, el commit es el que agrega realmente el archivo en una rama.
        Si hay archivos iguales en otra rama y te vas a cambiar a ella, procura add y commit en la rama actual porque se van a perder y serán reemplazados por los archivos de igual nombre de la otra rama.
        
        Con cat NAMEFILE y cambiando de rama y nuevamente ejecutando cat NAMEFILE puedes ver ambos archivos y ver sus diferencias.


    TRAERNOS LOS CAMBIOS DE UNA RAMA A OTRA
        Debemos ubicarnos en la rama a la que se quieren traer esos cambios y ejecutar
            git merge NAMERAMA


REPOSITORIO
    Subir nuestro codigo a la nube con github
    New repository, name, public, not check nothing
    Copia y pega en git 

    Unirnos al repo
        git remote add origina https....
            git remote      para indicarle que tenemos un servidor remoto en el cual subir nuestros cambios
            add origin      de donde obtendremos nuestro codigo y hacia donde se subiran
            https....       url donde están almacenados nuestros archivos (quedarán ps)

    Añadir rama al repo
        git push -u origin main     -> la rama de main no se halla creada en github así se crea
            git push        subir nuestros cambios con respecto a la rama con la que estamos trabajando
            -u              para crear la rama
            origin          donde será creada
            main            NAMERAMA

            Osea creame en el repo una rama llamada NAMERAMA y sube ahí lo que tengo en la rama en la que estoy justo ahora en Git Bash.
    
            Username:
                Coloca tu nombre de usuario
                Adrianfpg14-qwerty
            Password:
                No es la contraseña de git
                Vete a github/on your profile photo -> settings/developer settings/Personal access tokens/Generate new token:
                Note: name de pc/usuario pc/lo que sea
                Expiration: 30 days
                checks: repo (all of repo) (Alcance del token)
                Creala y copia el hash que te aparece y usa eso como contraseña en Git Bash

                
    Añadir cambios al repo
        git push
            Despues del commit (trabaja solo en local) sube los cambios de la rama local en el repo (Ahora si global)

        Si tienes otra rama en el local, y la quieres subir al repo:
        git checkout NAMEOTRARAMA           Te cambias en Git Bash de rama
        git push -u origin NAMEOTRARAMA     Creas la rama en el repo y la subes


REPOSITORIO 2
    Lo creas en github y copias el https en Code, te ubicas en un lugar donde se descargará la carpeta y das:
    git clone   https://github.com/Adrianfpg14-qwerty/repo2.git
                https://github.com/USUARIODUEÑO/NAMEREPO.git

    
ERRORES 
    GIT Bash (backspace goes forward like an space)
        Right click on the menu/title bar of git bash, select options, click on terminal from the options on the left, under the 'type' dropdown, select 'xterm', then apply and save. Now open a new git bash and it should work :D.
    Git es sensible UPPERCASE, los comandos deben ser en minuscula.